<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>For vs Since — Card Match (A2)</title>
<style>
  :root{
    --bg:#FDFBED; --ink:#222;
    --edge:#B5B5B5;              /* neutral grey borders */
    --ok:#1E8E3E; --bad:#B00020; --muted:#9aa1a8; --card:#fff;
  }
  *{box-sizing:border-box}
  body{
    margin:0; background:var(--bg); color:var(--ink);
    font-family:"MS Reference Sans Serif", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    min-height:100dvh; display:flex; align-items:center; justify-content:center; padding:16px;
  }
  .app{width:min(900px,100%); display:flex; flex-direction:column; gap:14px}
  header{display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:10px}
  h1{font-size:1.2rem; margin:0}
  .controls{display:flex; gap:8px}
  button{
    border:2px solid var(--edge); background:#fff; color:#000; padding:6px 10px; border-radius:999px;
    font-weight:600; cursor:pointer; transition:transform .06s ease, background .2s ease;
  }
  button:hover{transform:translateY(-1px)}
  .meta{font-size:.9rem; color:#333}
  .muted{color:var(--muted)}

  /* Word banks (shared container) */
  .banks{
    display:flex; gap:16px; flex-wrap:wrap;
    background:#fff; border:1px dashed var(--edge); border-radius:10px; padding:10px;
  }
  .bankWrap{flex:1; min-width:140px}
  .bankTitle{font-weight:700; margin:0 0 4px 0; font-size:.9rem}
  .bank{display:flex; flex-wrap:wrap; gap:6px; min-height:38px}

  /* Word chips */
  .pill{
    display:inline-flex; align-items:center; justify-content:center;
    min-width:56px; padding:5px 10px; border-radius:999px;
    border:2px solid var(--edge); background:#fff; font-weight:700; cursor:pointer;
    transition:box-shadow .15s ease, background .15s ease; user-select:none;
    touch-action: none;                      /* enable custom touch-drag */
    -webkit-tap-highlight-color: transparent;
  }
  .pill.selected{box-shadow:0 0 0 3px rgba(0,0,0,.12)} /* subtle grey focus */

  /* Sentences grid (compact) */
  .grid{display:grid; grid-template-columns:1fr; gap:8px}
  @media (min-width:650px){ .grid{grid-template-columns:1fr 1fr} }
  .card{
    background:var(--card); border:1px solid #ddd; border-radius:8px;
    padding:8px 10px; font-size:1rem; line-height:1.45;
    display:flex; align-items:center; position:relative;
  }
  .sentence{margin:0}

  /* Blank styled to MATCH pill shape, fixed width to prevent layout shift */
  .blank{
    display:inline-flex; align-items:center; justify-content:center;
    width:64px; min-height:34px; padding:3px 10px; margin:0 4px;
    border:2px dashed var(--edge); border-radius:999px;
    background:#fff; vertical-align:middle;
    transition:background .15s ease, border-color .15s ease, outline-color .15s ease;
    touch-action: none;
    -webkit-tap-highlight-color: transparent;
  }
  .blank.ready{outline:3px solid rgba(0,0,0,.10)}
  .blank.filled{border-style:solid;}
  .blank.correct{border-color:var(--ok); background:#ecf6ef}
  .blank.incorrect{border-color:var(--bad); background:#faecef}

  /* Chip appearance when sitting inside a blank */
  .blank .pill{
    /* keep it interactable so you can drag/tap to move/swap */
    border:0; background:transparent; padding:0; min-width:auto;
    cursor:grab;
  }

  .resultMark{
    position:absolute; top:6px; right:8px; font-weight:800;
    font-size:.9rem; user-select:none;
  }
  .tick{color:var(--ok)}
  .cross{color:var(--bad)}

  /* Floating ghost for touch-drag */
  .drag-ghost{
    position:fixed; z-index:9999; transform:translate(-50%,-50%);
    opacity:.95; pointer-events:none;
    border-radius:999px; border:2px solid var(--edge); background:#fff;
    padding:5px 10px; font-weight:700;
  }

  /* Result overlay */
  .overlay{
    position:fixed; inset:0; display:none; align-items:center; justify-content:center;
    background:rgba(0,0,0,.55); padding:16px; z-index:10000;
  }
  .overlay.show{ display:flex; }
  .resultCard{
    position:relative; background:#fff; border-radius:16px; padding:16px;
    width:min(520px, 92vw); box-shadow:0 12px 36px rgba(0,0,0,.25); text-align:center;
  }
  .resultCard img{ max-width:100%; height:auto; border-radius:12px; display:block; margin:0 auto 10px; }
  .resultCaption{ margin:0 0 10px 0; font-weight:600; }
  .overlayButtons{ display:flex; gap:8px; justify-content:center; }
  .closeBtn{
    position:absolute; top:8px; right:8px; border:none; border-radius:999px;
    width:32px; height:32px; font-size:20px; line-height:28px; cursor:pointer;
    background:#fff; border:2px solid var(--edge);
  }
</style>
</head>
<body>
  <div class="app">
    <header>
      <h1>For vs Since — Card Match</h1>
      <div class="controls">
        <button id="btnReset">Reset</button>
        <button id="btnCheck">Check answers</button>
      </div>
    </header>

    <div class="meta muted" id="summary">Tap or drag words into the blanks. You can move them later; dropping on another filled blank will swap them. Then press “Check answers”.</div>

    <section class="banks">
      <div class="bankWrap">
        <p class="bankTitle">Word bank — for</p>
        <div class="bank" id="bankFor"></div>
      </div>
      <div class="bankWrap">
        <p class="bankTitle">Word bank — since</p>
        <div class="bank" id="bankSince"></div>
      </div>
    </section>

    <section class="grid" id="grid"></section>
  </div>

  <!-- Result overlay -->
  <div class="overlay" id="resultOverlay" aria-hidden="true">
    <div class="resultCard">
      <button class="closeBtn" id="overlayClose" aria-label="Close">×</button>
      <img id="resultImg" alt="Result" />
      <p class="resultCaption" id="resultCaption"></p>
      <div class="overlayButtons">
        <button id="overlayRetry">Try again</button>
      </div>
    </div>
  </div>

<script>
const SENTENCES = [
  { text: "I’ve lived in Melbourne ___ 2020.", answer: "since" },
  { text: "She has studied English ___ three years.", answer: "for" },
  { text: "They’ve been friends ___ childhood.", answer: "since" },
  { text: "We’ve waited here ___ half an hour.", answer: "for" },
  { text: "He has worked at the café ___ Monday.", answer: "since" },
  { text: "I’ve known her ___ a long time.", answer: "for" },
  { text: "The shop has been open ___ two hours.", answer: "for" },
  { text: "She has played the piano ___ she was a child.", answer: "since" },
  { text: "We’ve stayed in this hotel ___ last Friday.", answer: "since" },
  { text: "I’ve had this phone ___ six months.", answer: "for" }
];

const URLS = {
  perfectImg: "https://schredder222.github.io/Assets/You%20Nailed%20It.png",
  goodImg:    "https://schredder222.github.io/Assets/Bad%20bad.png",
  tryImg:     "https://schredder222.github.io/Assets/Keep%20Practising.png",
  applause:   "https://schredder222.github.io/Assets/Applause.mp3"
};

const grid = document.getElementById('grid');
const bankFor = document.getElementById('bankFor');
const bankSince = document.getElementById('bankSince');
const btnReset = document.getElementById('btnReset');
const btnCheck = document.getElementById('btnCheck');
const summaryEl = document.getElementById('summary');

const overlay = document.getElementById('resultOverlay');
const overlayClose = document.getElementById('overlayClose');
const overlayRetry = document.getElementById('overlayRetry');
const resultImg = document.getElementById('resultImg');
const resultCaption = document.getElementById('resultCaption');

let state = { selected:null, checked:false };
let applauseAudio = new Audio(URLS.applause);

function shuffle(arr){return arr.map(v=>[Math.random(),v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);}

function build(){
  grid.innerHTML = bankFor.innerHTML = bankSince.innerHTML = '';
  state.selected=null; state.checked=false;
  summaryEl.textContent = "Tap or drag words into the blanks. You can move or swap them. Then press “Check answers”.";
  btnCheck.disabled=false;

  hideOverlay(); stopApplause();

  // sentences
  shuffle([...SENTENCES]).forEach((s)=>{
    const card=document.createElement('div');
    card.className='card';
    const [pre,post]=s.text.split('___');

    const span=document.createElement('span');
    span.className='blank'; span.dataset.answer=s.answer;

    // Click placement
    span.addEventListener('click',()=>tryPlace(span));

    // Desktop drag target (native DnD)
    span.addEventListener('dragover', e=>{ if(state.checked) return; e.preventDefault(); span.classList.add('ready'); e.dataTransfer.dropEffect='move'; });
    span.addEventListener('dragleave', ()=> span.classList.remove('ready'));
    span.addEventListener('drop', e=>{
      if(state.checked) return; e.preventDefault(); span.classList.remove('ready');
      const id = e.dataTransfer.getData('text/id');
      const chip = document.getElementById(id);
      if(chip) placeChip(chip, span);
    });

    const p=document.createElement('p');
    p.className='sentence';
    p.append(pre, span, post||'');
    card.appendChild(p);

    const mark=document.createElement('div'); mark.className='resultMark';
    card.appendChild(mark);

    grid.appendChild(card);
  });

  // banks
  makeBank('for', bankFor, SENTENCES.filter(s=>s.answer==='for').length);
  makeBank('since', bankSince, SENTENCES.filter(s=>s.answer==='since').length);

  // enable desktop dropping back onto banks
  enableBankDnD(bankFor);
  enableBankDnD(bankSince);
}

function makeBank(type,container,count){
  for(let i=0;i<count;i++){
    const chip=document.createElement('div');
    chip.className='pill';
    chip.textContent=type;
    chip.draggable=true;                       // desktop DnD
    chip.dataset.value=type;
    chip.id = `chip-${type}-${i}-${Math.random().toString(36).slice(2)}`;

    // Click-to-select (tap)
    chip.addEventListener('click',()=>{
      if(state.checked) return;
      if(state.selected && state.selected!==chip) state.selected.classList.remove('selected');
      chip.classList.toggle('selected');
      state.selected = chip.classList.contains('selected') ? chip : null;
    });

    // Desktop drag source (native DnD)
    chip.addEventListener('dragstart', e=>{
      if(state.checked){ e.preventDefault(); return; }
      chip.classList.add('selected');
      state.selected = chip;
      e.dataTransfer.setData('text/id', chip.id);
      e.dataTransfer.effectAllowed='move';
    });
    chip.addEventListener('dragend', ()=> chip.classList.remove('selected'));

    // Mobile touch-drag fallback
    addTouchDrag(chip);

    container.appendChild(chip);
  }
}

function enableBankDnD(container){
  container.addEventListener('dragover', e=>{ if(state.checked) return; e.preventDefault(); e.dataTransfer.dropEffect='move'; });
  container.addEventListener('drop', e=>{
    if(state.checked) return; e.preventDefault();
    const id = e.dataTransfer.getData('text/id');
    const chip = document.getElementById(id);
    if(!chip) return;
    sendToBank(chip, container);
  });
}

/* Click-to-place helper */
function tryPlace(blank){
  if(state.checked) return;
  const chip=state.selected;
  if(!chip) return;
  placeChip(chip, blank);
}

/* Move a chip back to a bank (from blank or wherever) */
function sendToBank(chip, container){
  const oldParent = chip.parentElement;
  container.appendChild(chip);
  chip.classList.remove('selected');
  state.selected=null;
  if(oldParent && oldParent.classList && oldParent.classList.contains('blank')){
    oldParent.classList.remove('filled','correct','incorrect');
    const mark = oldParent.closest('.card').querySelector('.resultMark'); if(mark) mark.textContent='';
  }
}

/* Core placement (click + drag + swap logic) */
function placeChip(chip, blank){
  if(state.checked) return;

  const destCard = blank.closest('.card');
  if(destCard){ const mk = destCard.querySelector('.resultMark'); if(mk) mk.textContent=''; }

  const existing = blank.querySelector('.pill');
  const src = chip.parentElement;

  // no-op if trying to place into its own blank
  if(src === blank){
    chip.classList.remove('selected'); state.selected=null; return;
  }

  // same word already there -> no change
  if(existing && existing.dataset.value === chip.dataset.value){
    chip.classList.remove('selected'); state.selected=null; return;
  }

  // SWAP if destination has a chip and source is another blank
  if(existing && src && src.classList && src.classList.contains('blank')){
    // clear feedback on both cards
    [src, blank].forEach(b=>{
      b.classList.remove('correct','incorrect');
      const mk = b.closest('.card').querySelector('.resultMark'); if(mk) mk.textContent='';
    });
    // perform swap
    src.appendChild(existing);
    blank.appendChild(chip);
    src.classList.add('filled');
    blank.classList.add('filled');
    chip.classList.remove('selected'); state.selected=null;
    return;
  }

  // If destination has a chip and source is NOT a blank (i.e., from bank), send existing back to its bank
  if(existing){
    (existing.dataset.value==='for'?bankFor:bankSince).appendChild(existing);
  }

  // if moving from another blank (and not swapping), tidy the source blank
  if(src && src.classList && src.classList.contains('blank')){
    src.classList.remove('filled','correct','incorrect');
    const mk2 = src.closest('.card').querySelector('.resultMark'); if(mk2) mk2.textContent='';
  }

  blank.appendChild(chip);
  blank.classList.add('filled');
  chip.classList.remove('selected');
  state.selected=null;
}

/* Check answers — marks all cards and shows end screen */
btnCheck.addEventListener('click', ()=>{
  if(state.checked) return;

  let correct = 0;
  const blanks = document.querySelectorAll('.blank');

  blanks.forEach(b => {
    const card = b.closest('.card');
    const mark = card ? card.querySelector('.resultMark') : null;
    b.classList.remove('correct','incorrect');
    if (mark) mark.textContent = '';

    const chip = b.querySelector('.pill');
    if (chip && chip.dataset.value === b.dataset.answer) {
      b.classList.add('correct');
      if (mark) mark.innerHTML = '<span class="tick">✓</span>';
      correct++;
    } else {
      b.classList.add('incorrect');
      if (mark) mark.innerHTML = '<span class="cross">✗</span>';
    }
  });

  summaryEl.textContent = `Score: ${correct}/${blanks.length}`;
  state.checked = true;
  btnCheck.disabled = true;

  // Show result overlay with image/audio
  showEndScreen(correct, blanks.length);
});

/* End screen logic */
function showEndScreen(correct, total){
  let src = URLS.tryImg;
  if (correct === total){
    src = URLS.perfectImg;
    stopApplause();
    applauseAudio = new Audio(URLS.applause);
    applauseAudio.play().catch(()=>{});
  } else if (correct >= 7){
    src = URLS.goodImg;
    stopApplause();
  } else {
    src = URLS.tryImg;
    stopApplause();
  }

  resultImg.src = src;
  resultImg.alt = `Result image for score ${correct}/${total}`;
  resultCaption.textContent = `Score: ${correct} / ${total}`;
  showOverlay();
}

function showOverlay(){
  overlay.classList.add('show');
  overlay.setAttribute('aria-hidden','false');
}
function hideOverlay(){
  overlay.classList.remove('show');
  overlay.setAttribute('aria-hidden','true');
}
function stopApplause(){
  if(applauseAudio){
    try{ applauseAudio.pause(); applauseAudio.currentTime = 0; }catch(e){}
  }
}

/* Overlay controls */
overlayClose.addEventListener('click', hideOverlay);
overlayRetry.addEventListener('click', ()=>{ hideOverlay(); build(); });
overlay.addEventListener('click', (e)=>{ if(e.target === overlay) hideOverlay(); });

/* Reset */
btnReset.addEventListener('click', build);

/* ---------- Touch-drag fallback (mobile) ---------- */
function addTouchDrag(chip){
  let dragging=false, ghost=null, startX=0, startY=0, lastBlank=null, lastBank=null;

  const onStart = (e)=>{
    if(state.checked) return;
    const t = e.touches && e.touches[0];
    if(!t) return;
    startX = t.clientX; startY = t.clientY;
    dragging=false; lastBlank=null; lastBank=null;
    chip.classList.add('selected');
    state.selected = chip;

    document.addEventListener('touchmove', onMove, {passive:false});
    document.addEventListener('touchend', onEnd, {passive:false});
  };

  const onMove = (e)=>{
    const t = e.touches && e.touches[0];
    if(!t) return;
    const dx = t.clientX - startX, dy = t.clientY - startY;

    // Start dragging after a small threshold so taps still work and page can scroll otherwise
    if(!dragging && (Math.abs(dx) > 6 || Math.abs(dy) > 6)){
      dragging = true;
      ghost = document.createElement('div');
      ghost.className = 'drag-ghost';
      ghost.textContent = chip.dataset.value;
      document.body.appendChild(ghost);
    }

    if(dragging){
      e.preventDefault(); // stop page scroll while dragging
      ghost.style.left = t.clientX + 'px';
      ghost.style.top  = t.clientY + 'px';

      const el = document.elementFromPoint(t.clientX, t.clientY);
      // manage hover state for blanks
      const b = el ? el.closest('.blank') : null;
      if(b !== lastBlank){
        if(lastBlank) lastBlank.classList.remove('ready');
        if(b) b.classList.add('ready');
        lastBlank = b;
      }
      // also remember if we're over a bank
      lastBank = el ? el.closest('.bank') : null;
    }
  };

  const onEnd = (e)=>{
    document.removeEventListener('touchmove', onMove, {passive:false});
    document.removeEventListener('touchend', onEnd, {passive:false});

    if(lastBlank) lastBlank.classList.remove('ready');
    if(ghost && ghost.parentNode) ghost.parentNode.removeChild(ghost);
    ghost=null;

    if(dragging){
      if(lastBlank){
        placeChip(chip, lastBlank);
      }else if(lastBank){
        sendToBank(chip, lastBank);
      }
      chip.classList.remove('selected');
      state.selected=null;
    }else{
      // It was just a tap; keep selection toggled by click handler.
    }

    dragging=false; lastBlank=null; lastBank=null;
  };

  chip.addEventListener('touchstart', onStart, {passive:true});
}

/* Init */
build();
</script>
</body>
</html>
