<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes, maximum-scale=5" />
<title>Definition Matching – City Life (A2)</title>
<style>
  :root{
    --bg:#FDFBED;
    --ink:#222;
    --accent:#8A0000;
    --ok:#1E8E3E;
    --card:#fff;
    --gap:28px;       /* centre gap (desktop/tablet) */
    --dot:10px;       /* dot size (desktop) */
    --dotColor:#000;
    --minCol:120px;   /* minimum per column */
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    background:var(--bg);
    color:var(--ink);
    font-family:"MS Reference Sans Serif", Arial, sans-serif;
  }
  .wrap{max-width:1000px;margin:24px auto;padding:16px}
  h1{font-weight:600;font-size:1.3rem;margin:0 0 10px}
  .note{font-size:.95rem;color:#444;margin:0 0 16px;line-height:1.45}

  .board{
    position:relative;
    display:grid;
    grid-template-columns:max-content 1fr max-content; /* left | gap | right */
    column-gap:var(--gap);
    align-items:start;
    background:var(--card);
    border-radius:14px;
    box-shadow:0 6px 24px rgba(0,0,0,.08);
    padding:72px 18px 72px;  /* space under timer */
    overflow:hidden;
    touch-action: pan-y; /* keep vertical scroll; we disable on handles */
    -webkit-user-select:none; user-select:none;
    -webkit-touch-callout:none;
  }
  #leftCol { grid-column:1; }
  #rightCol{ grid-column:3; }

  /* Topbar (timer left + mute right) */
  .topbar{
    position:absolute; top:12px; left:18px; right:18px;
    display:flex; align-items:center; justify-content:space-between; gap:12px;
    z-index:300;
  }
  .timer{
    background:#111; color:#fff; padding:6px 12px; border-radius:999px;
    font-weight:600; letter-spacing:.3px; box-shadow:0 2px 10px rgba(0,0,0,.12);
  }

  /* Icon-only mute button */
  .muteBtn{
    display:none; /* shown after audio starts */
    width:40px; height:40px;
    border:none; border-radius:50%;
    background-color:#eee;
    background-repeat:no-repeat;
    background-position:center;
    background-size:22px 22px;
    box-shadow:0 2px 8px rgba(0,0,0,.08);
    cursor:pointer;
  }
  /* aria-pressed="false" = playing (show Unmute icon), true = muted (show Mute icon) */
  .muteBtn[aria-pressed="false"]{
    background-image:url('https://schredder222.github.io/Assets/Unmute.svg');
  }
  .muteBtn[aria-pressed="true"]{
    background-image:url('https://schredder222.github.io/Assets/Mute.svg');
  }

  .wires{
    position:absolute; inset:0;
    z-index:100; pointer-events:none;
  }

  .col{display:flex;flex-direction:column;gap:10px}
  .head{
    font-weight:600;
    font-size:18px;
    letter-spacing:.3px;
    color:#111;
    margin-bottom:8px;
    text-align:center;
  }

  .item{
    position:relative;
    background:#fff;
    border:1px solid #eee;
    border-radius:12px;
    min-height:42px;
    display:flex;align-items:center;
    line-height:1.25;
    box-shadow:0 2px 10px rgba(0,0,0,.04);
    width:var(--colWidth);   /* set per-column via JS */
    max-width:100%;
    overflow:hidden;
  }
  .left.item { padding:10px 34px 10px 14px; }
  .right.item{ padding:10px 14px 10px 34px; }

  .item p{
    margin:0;
    white-space:nowrap;          /* desktop default */
    text-overflow:ellipsis;
    overflow:hidden;
  }
  .item.wrap p{
    white-space:normal;
    overflow:visible;
    text-overflow:clip;
  }

  .handle{
    position:absolute;top:50%;transform:translateY(-50%);
    width:var(--dot);height:var(--dot);border-radius:50%;
    background:var(--dotColor);
    cursor:pointer; z-index:200;
    touch-action:none;
    -webkit-user-select:none; user-select:none;
  }
  .left .handle{right:8px}
  .right .handle{left:8px}

  /* Larger invisible halo for touch without changing visual size */
  .handle::after{
    content:"";
    position:absolute;
    inset:-12px;
  }

  /* Optional: subtle glow on the target dot we're locked to */
  .handle.hot{ box-shadow:0 0 0 6px rgba(138,0,0,.15); }

  .controls{
    position:absolute;left:18px;right:18px;bottom:16px;
    display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap
  }
  .btn{
    background:var(--accent);color:#fff;border:none;padding:10px 16px;border-radius:10px;
    font-weight:600;letter-spacing:.2px;cursor:pointer;box-shadow:0 3px 10px rgba(138,0,0,.25)
  }
  .btn[disabled]{opacity:.45;cursor:not-allowed;box-shadow:none}
  .ghost{background:#eee;color:#111;box-shadow:none}

  /* Tablets slightly reduce gap */
  @media (max-width:640px){
    :root{ --gap:24px; }
  }

  /* Phones: equal widths, per-row equal heights, aligned dots, smaller text, tighter gaps */
  @media (max-width:520px){
    :root{
      --gap:16px;
      --dot:14px;
      --minCol:100px;
    }
    .board{ padding:62px 12px 62px; }
    .col{ gap:4px; }                 /* tiny vertical gap */
    .item{
      border-radius:10px;
      align-items:center;
      min-height:48px;               /* baseline; final height equalised by JS */
    }
    .left.item{  padding:10px 30px 10px 12px; }
    .right.item{ padding:10px 12px 10px 30px; }

    /* smaller text, wrap fully so the row can grow to fit */
    .item p{
      white-space:normal;
      font-size:0.86rem;
      line-height:1.25;
      overflow:visible;
      text-overflow:clip;
      word-break:break-word;
    }

    .head{ font-size:16px; margin-bottom:6px; }
    .timer{ padding:5px 10px; }
    .muteBtn{ width:36px; height:36px; background-size:20px 20px; }
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>Word-Definition Match</h1>
  <p class="note">Match the keywords from the video with their definitions by dragging lines between the dots. Then click “Check answers”.</p>

  <div class="board" id="board">
    <!-- Topbar -->
    <div class="topbar">
      <div class="timer" id="timer">00:00</div>
      <button class="muteBtn" id="muteBtn" aria-pressed="false" aria-label="Mute background music"></button>
    </div>

    <svg class="wires" id="wires" aria-hidden="true"></svg>

    <div class="col left" id="leftCol">
      <div class="head">Words</div>
    </div>

    <div class="col right" id="rightCol">
      <div class="head">Definitions</div>
    </div>

    <div class="controls">
      <div>
        <button class="btn ghost" id="shuffleBtn">Shuffle</button>
        <button class="btn ghost" id="resetBtn">Reset</button>
        <button class="btn" id="checkBtn" disabled>Check answers</button>
        <button class="btn ghost" id="showBtn">Show answers</button>
      </div>
    </div>
  </div>
</div>

<!-- Audio effects -->
<audio id="correctSound" preload="metadata" src="https://cdn.pixabay.com/download/audio/2022/03/24/audio_dcde83efa6.mp3?filename=ui_correct_button2-103167.mp3"></audio>
<audio id="incorrectSound" preload="metadata" src="https://cdn.pixabay.com/download/audio/2022/03/15/audio_b0669294aa.mp3?filename=training-program-incorrect1-88736.mp3"></audio>
<audio id="clickSound" preload="metadata" src="https://cdn.pixabay.com/download/audio/2024/04/21/audio_1b8d3bcd3d.mp3?filename=click-buttons-ui-menu-sounds-effects-button-7-203601.mp3"></audio>
<audio id="connectSound" preload="metadata" src="https://cdn.pixabay.com/download/audio/2025/05/23/audio_ec08d1525d.mp3?filename=click-345983.mp3"></audio>

<!-- Background music (loop) -->
<audio id="bgm" preload="metadata" loop src="https://cdn.pixabay.com/download/audio/2025/09/03/audio_a8c05eb5c8.mp3"></audio>

<script>
/* ---- Data ---- */
const PAIRS = [
  { id:"opportunities", left:"opportunities", right:"chances to get jobs or do something good" },
  { id:"skyscraper",  left:"skyscraper",  right:"very tall city building with many floors" },
  { id:"crowded",      left:"crowded",      right:"full of people so there isn’t much space" },
  { id:"rushhour",     left:"peak time / rush hour", right:"the busy time of day when many people travel" },
  { id:"congested",    left:"congested",    right:"very full of cars so traffic moves slowly" },
  { id:"trafficjam",  left:"traffic jam", right:"long line of vehicles that are not moving" },
  { id:"greenspaces",  left:"green spaces", right:"parks and gardens in a city" },
  { id:"pollution",    left:"pollution",    right:"dirty air/water that harms people and nature" }
];

const board   = document.getElementById('board');
const leftCol = document.getElementById('leftCol');
const rightCol= document.getElementById('rightCol');
const wires   = document.getElementById('wires');
const checkBtn= document.getElementById('checkBtn');
const resetBtn= document.getElementById('resetBtn');
const shuffleBtn= document.getElementById('shuffleBtn');
const showBtn = document.getElementById('showBtn');

const correctSound = document.getElementById('correctSound');
const incorrectSound = document.getElementById('incorrectSound');
const clickSound = document.getElementById('clickSound');
const connectSound = document.getElementById('connectSound');

const timerEl = document.getElementById('timer');
const muteBtn = document.getElementById('muteBtn');
const bgm     = document.getElementById('bgm');

const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
const isMobile = () => window.matchMedia('(max-width:520px)').matches;

let leftOrder=[], rightOrder=[];
let connections=new Map(); // leftId -> { rightId, el }
let drag=null;
let dragActive=false;

/* ---- Snapping (hit-test, no guessing) ---- */
const getHitRadius   = () => isMobile() ? 26 : 18; // must be inside this to lock
const getLeaveRadius = () => getHitRadius() + 8;   // must exit this to unlock

/* ---- Timer/music ---- */
let timerStarted=false, timerFrozen=false, timerStartMs=0, timerInterval=null, hasAudioPlayed=false, timerHiddenForAnswers=false;

const fmtTime = (ms)=>{ const t=Math.floor(ms/1000), m=(t/60|0), s=t%60; return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`; };

function startTimerAndMusic(){
  if(!timerStarted){
    timerStarted = true; timerFrozen=false; timerStartMs=Date.now();
    timerEl.style.visibility='visible'; timerHiddenForAnswers=false;
    timerEl.textContent='00:00';
    timerInterval = setInterval(()=>{ if(!timerFrozen){ timerEl.textContent = fmtTime(Date.now()-timerStartMs); } }, 250);

    bgm.volume = 0.1;
    const p = bgm.play();
    if (p && typeof p.then==='function'){ p.then(()=>{ if(!hasAudioPlayed){ hasAudioPlayed=true; muteBtn.style.display='inline-block'; } }).catch(()=>{}); }
  }
}
function freezeTimerWithMessage(){ if(timerStarted && !timerFrozen){ timerFrozen=true; clearInterval(timerInterval); timerInterval=null; timerEl.textContent=`Completed in ${fmtTime(Date.now()-timerStartMs)}`; } }
function hideTimerKeepSpace(){ timerHiddenForAnswers=true; timerStarted=false; timerFrozen=true; clearInterval(timerInterval); timerInterval=null; timerEl.style.visibility='hidden'; }
function showTimerResetToZero(){ timerEl.style.visibility='visible'; timerEl.textContent='00:00'; timerStarted=false; timerFrozen=false; timerHiddenForAnswers=false; }
function showTimerIfHidden(){ if (timerEl.style.visibility==='hidden'){ timerEl.style.visibility='visible'; timerHiddenForAnswers=false; } }

/* ---- Utils ---- */
const shuffle=a=>{a=a.slice();for(let i=a.length-1;i>0;i--){const j=(Math.random()*(i+1))|0;[a[i],a[j]]=[a[j],a[i]]}return a};
const rectOf = el => el.getBoundingClientRect();
function boardPointFromClient(x,y){ const b = rectOf(board); return { x:x - b.left, y:y - b.top }; }

/* Create row item */
function createItem(colEl, text, id, side){
  const div = document.createElement('div');
  div.className = 'item ' + side;
  div.dataset.id = id;
  const p = document.createElement('p'); p.textContent = text; div.appendChild(p);
  const h = document.createElement('div'); h.className = 'handle'; div.appendChild(h);
  colEl.appendChild(div);
}

/* Measurement */
function measureTextWidth(text, classSelector){
  let meas = document.getElementById('measSpan');
  if(!meas){
    meas = document.createElement('span'); meas.id='measSpan';
    Object.assign(meas.style,{position:'absolute',left:'-99999px',top:'-99999px',whiteSpace:'nowrap'});
    document.body.appendChild(meas);
  }
  const sample = document.querySelector(classSelector);
  const cs = sample ? getComputedStyle(sample) : getComputedStyle(document.body);
  meas.style.fontFamily = cs.fontFamily; meas.style.fontSize=cs.fontSize; meas.style.fontWeight=cs.fontWeight; meas.style.letterSpacing=cs.letterSpacing;
  meas.textContent = text;
  return meas.offsetWidth;
}

/* Column widths (equal on mobile) */
function setColumnUniformWidths(){
  const leftItems = [...document.querySelectorAll('#leftCol .item')];
  const rightItems= [...document.querySelectorAll('#rightCol .item')];
  if (!leftItems.length || !rightItems.length) return;

  const mobile = isMobile();
  const boardCS = getComputedStyle(board);
  const inner = board.clientWidth - parseFloat(boardCS.paddingLeft||0) - parseFloat(boardCS.paddingRight||0);
  const gapPx = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap'))||0;
  const totalGaps = gapPx * 2;
  const minCol = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--minCol'))||120;

  if (mobile) {
    leftItems.forEach(i => i.classList.add('wrap'));
    rightItems.forEach(i=> i.classList.add('wrap'));
    const equalW = Math.max(minCol, Math.floor((inner - totalGaps) / 2));
    [...leftItems, ...rightItems].forEach(i => i.style.setProperty('--colWidth', equalW + 'px'));
  } else {
    let leftTextMax=0, rightTextMax=0;
    leftItems.forEach(it=> leftTextMax  = Math.max(leftTextMax,  measureTextWidth(it.querySelector('p').textContent, '.item p')));
    rightItems.forEach(it=> rightTextMax = Math.max(rightTextMax, measureTextWidth(it.querySelector('p').textContent, '.item p')));
    const padL = getComputedStyle(leftItems[0]), padR = getComputedStyle(rightItems[0]);
    const leftW  = Math.max(minCol, leftTextMax  + parseFloat(padL.paddingLeft||0) + parseFloat(padL.paddingRight||0) + 22);
    let   rightW = Math.max(minCol, rightTextMax + parseFloat(padR.paddingLeft||0) + parseFloat(padR.paddingRight||0) + 22);
    let   finalL = leftW, finalR = rightW;
    if (finalL + finalR + totalGaps > inner){ finalR = Math.max(minCol, inner - totalGaps - finalL); }
    leftItems.forEach(i => i.classList.remove('wrap'));
    if (finalL + finalR + totalGaps > inner){
      finalL = Math.max(minCol, inner - totalGaps - finalR);
      leftItems.forEach(i => i.classList.add('wrap'));
    }
    leftItems.forEach(i => i.style.setProperty('--colWidth', finalL + 'px'));
    rightItems.forEach(i=> i.style.setProperty('--colWidth', finalR + 'px'));
  }

  const b = rectOf(board);
  wires.setAttribute('width', b.width);
  wires.setAttribute('height', b.height);
}

/* Equal row heights on mobile so dots align */
function equaliseRowHeights(){
  const mobile = isMobile();
  const L=[...document.querySelectorAll('#leftCol .item')];
  const R=[...document.querySelectorAll('#rightCol .item')];
  const n = Math.min(L.length,R.length);
  for(let i=0;i<n;i++){ L[i].style.height = R[i].style.height = 'auto'; }
  if (!mobile) return;
  for(let i=0;i<n;i++){
    const h = Math.max(48, L[i].scrollHeight, R[i].scrollHeight);
    L[i].style.height = R[i].style.height = h + 'px';
  }
}

/* Handle centre */
function handleCenter(handleEl){
  const b = rectOf(board), r = rectOf(handleEl);
  return { x: r.left - b.left + r.width/2, y: r.top - b.top + r.height/2 };
}

/* Mobile: straight lines; Desktop: curves */
function makeConnectorElement(colorVar='--accent', width=3){
  const color = getComputedStyle(document.documentElement).getPropertyValue(colorVar).trim() || 'red';
  if (isMobile()){
    const ln = document.createElementNS('http://www.w3.org/2000/svg','line');
    ln.setAttribute('stroke', color); ln.setAttribute('stroke-width', width); ln.setAttribute('stroke-linecap','round');
    return ln;
  }else{
    const p = document.createElementNS('http://www.w3.org/2000/svg','path');
    p.setAttribute('fill','none'); p.setAttribute('stroke', color); p.setAttribute('stroke-width', width); p.setAttribute('stroke-linecap','round'); p.setAttribute('stroke-opacity','0.95');
    return p;
  }
}
function curveD(x1,y1,x2,y2){ const dx=Math.max(60, Math.abs(x2-x1)*0.5); return `M ${x1} ${y1} C ${x1+dx} ${y1}, ${x2-dx} ${y2}, ${x2} ${y2}`; }
function placeConnector(el, a, b, colorVar='--accent', width=3){
  const color = getComputedStyle(document.documentElement).getPropertyValue(colorVar).trim() || 'red';
  if (el.tagName.toLowerCase()==='line'){
    el.setAttribute('x1', a.x); el.setAttribute('y1', a.y);
    el.setAttribute('x2', b.x); el.setAttribute('y2', b.y);
  }else{
    el.setAttribute('d', curveD(a.x,a.y,b.x,b.y));
  }
  el.setAttribute('stroke', color); el.setAttribute('stroke-width', width);
}

/* Realign */
let rafId = null;
function rafRealign(){ if (rafId) return; rafId = requestAnimationFrame(()=>{ rafId=null; realignAllConnectors(); }); }
function realignAllConnectors(){
  for(const [leftId, conn] of connections){
    const lH = leftCol.querySelector(`.item[data-id="${leftId}"] .handle`);
    const rH = rightCol.querySelector(`.item[data-id="${conn.rightId}"] .handle`);
    if(!lH || !rH || !conn.el) continue;
    placeConnector(conn.el, handleCenter(lH), handleCenter(rH));
  }
}

/* Render */
function render(){
  leftCol.querySelectorAll('.item').forEach(n=>n.remove());
  rightCol.querySelectorAll('.item').forEach(n=>n.remove());
  leftOrder.forEach(({id,left})  => createItem(leftCol, left,  id,'left'));
  rightOrder.forEach(({id,right})=> createItem(rightCol,right, id,'right'));
  setColumnUniformWidths();
  equaliseRowHeights();
  attachEvents();
  attachTapToMatch();
  updateCheckState();
  realignAllConnectors();
}

/* ---------- STRICT HIT-TEST SNAPPING (hover lock) ---------- */
function handlesOn(side){ return [...document.querySelectorAll(`.${side} .handle`)]; }
function pickUnderPointer(pt, side){ // returns a handle only if pointer is inside its hit radius
  const list = handlesOn(side);
  let best=null, bestDist=Infinity;
  const r = getHitRadius();
  for(const h of list){
    const c = handleCenter(h);
    const d = Math.hypot(c.x-pt.x, c.y-pt.y);
    if (d <= r && d < bestDist){ best=h; bestDist=d; }
  }
  return best; // may be null if not close enough
}

/* Drag with hover lock */
function addStartDragHandler(handleEl, fromSide){
  handleEl.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    try{ handleEl.setPointerCapture && handleEl.setPointerCapture(e.pointerId); }catch(_){}
    dragActive = true;

    showTimerIfHidden(); startTimerAndMusic();

    const fromId = handleEl.parentElement.dataset.id;

    // Clear any existing connection on this side
    if(fromSide === 'left'){
      if(connections.has(fromId)){ connections.get(fromId).el?.remove(); connections.delete(fromId); }
    }else{
      for(const [lId, conn] of [...connections]){ if(conn.rightId === fromId){ conn.el?.remove(); connections.delete(lId); } }
    }

    const start = handleCenter(handleEl);
    const ghost = document.createElementNS('http://www.w3.org/2000/svg','line');
    const color = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || 'red';
    ghost.setAttribute('stroke', color); ghost.setAttribute('stroke-width', 3); ghost.setAttribute('stroke-linecap','round');
    ghost.setAttribute('x1', start.x); ghost.setAttribute('y1', start.y);
    ghost.setAttribute('x2', start.x); ghost.setAttribute('y2', start.y);
    wires.appendChild(ghost);

    drag = { fromSide, fromId, lineEl: ghost, hover: null };

    const setHover = (next)=>{
      if (drag.hover === next) return;
      if (drag.hover) drag.hover.classList.remove('hot');
      drag.hover = next;
      if (drag.hover) drag.hover.classList.add('hot');
    };

    const onMove = (ev)=>{
      if(!drag) return;
      const pt = boardPointFromClient(ev.clientX, ev.clientY);
      // Maintain lock unless pointer leaves leave-radius
      if (drag.hover){
        const c = handleCenter(drag.hover);
        const dist = Math.hypot(c.x-pt.x, c.y-pt.y);
        if (dist > getLeaveRadius()){ setHover(null); }
      }
      // If not locked, see if we're inside any target's hit radius
      if (!drag.hover){
        const side = (drag.fromSide === 'left') ? 'right' : 'left';
        const cand = pickUnderPointer(pt, side);
        if (cand) setHover(cand);
      }
      // Aim ghost: to locked target centre if any; otherwise to pointer
      if (drag.hover){
        const c = handleCenter(drag.hover);
        ghost.setAttribute('x2', c.x); ghost.setAttribute('y2', c.y);
      }else{
        ghost.setAttribute('x2', pt.x); ghost.setAttribute('y2', pt.y);
      }
    };

    const endDrag = ()=>{
      if(!drag) return;

      const target = drag.hover; // only connect if we were actually inside a dot
      const fromIdLocal = drag.fromId;
      const fromSideLocal = drag.fromSide;

      if (drag.hover) drag.hover.classList.remove('hot');
      drag.lineEl.remove();

      let leftId=null, rightId=null, ok=false;
      if(fromSideLocal === 'left' && target){ leftId=fromIdLocal; rightId=target.parentElement.dataset.id; ok=true; }
      if(fromSideLocal === 'right' && target){ leftId=target.parentElement.dataset.id; rightId=fromIdLocal; ok=true; }

      if(ok){
        if(connections.has(leftId)){ connections.get(leftId).el?.remove(); connections.delete(leftId); }
        for(const [lId, conn] of [...connections]){ if(conn.rightId === rightId){ conn.el?.remove(); connections.delete(lId); } }

        const lH = leftCol.querySelector(`.item[data-id="${leftId}"] .handle`);
        const rH = rightCol.querySelector(`.item[data-id="${rightId}"] .handle`);
        const el = makeConnectorElement('--accent', 3);
        placeConnector(el, handleCenter(lH), handleCenter(rH), '--accent', 3);
        wires.appendChild(el);
        connections.set(leftId, { rightId, el });

        connectSound.currentTime = 0; connectSound.play();
        if (!reduceMotion && navigator.vibrate) navigator.vibrate(10);
      }

      drag = null; dragActive=false;
      document.removeEventListener('pointermove', onMove);
      document.removeEventListener('pointerup', onUp);
      document.removeEventListener('pointercancel', onCancel);
      updateCheckState();

      // After drag ends, realign (and re-enable observers)
      setColumnUniformWidths(); equaliseRowHeights(); rafRealign();
    };

    const onUp = ()=> endDrag();
    const onCancel = ()=> endDrag();

    document.addEventListener('pointermove', onMove, {passive:false});
    document.addEventListener('pointerup', onUp, {passive:false});
    document.addEventListener('pointercancel', onCancel, {passive:false});
  });
}

/* Tap-to-match (simple, no visual outline) */
let pending = null;
function clearPending(){ pending = null; }
function setPending(next){ clearPending(); pending = next; }

function attachTapToMatch(){
  [...leftCol.querySelectorAll('.item')].forEach(el=>{
    el.addEventListener('click', ()=>{
      const id = el.dataset.id;
      if (!pending){ setPending({side:'left', id}); return; }
      if (pending.side === 'right'){ connectByIds(id, pending.id); clearPending(); }
      else setPending({side:'left', id});
    });
  });
  [...rightCol.querySelectorAll('.item')].forEach(el=>{
    el.addEventListener('click', ()=>{
      const id = el.dataset.id;
      if (!pending){ setPending({side:'right', id}); return; }
      if (pending.side === 'left'){ connectByIds(pending.id, id); clearPending(); }
      else setPending({side:'right', id});
    });
  });
}

function connectByIds(leftId, rightId){
  if(connections.has(leftId)){ connections.get(leftId).el?.remove(); connections.delete(leftId); }
  for(const [lId, conn] of [...connections]){ if(conn.rightId === rightId){ conn.el?.remove(); connections.delete(lId); } }
  const lH = leftCol.querySelector(`.item[data-id="${leftId}"] .handle`);
  const rH = rightCol.querySelector(`.item[data-id="${rightId}"] .handle`);
  if(!lH || !rH) return;
  const el = makeConnectorElement('--accent', 3);
  placeConnector(el, handleCenter(lH), handleCenter(rH), '--accent', 3);
  wires.appendChild(el);
  connections.set(leftId, { rightId, el });
  connectSound.currentTime = 0; connectSound.play();
  if (!reduceMotion && navigator.vibrate) navigator.vibrate(10);
  updateCheckState();
}

/* Attach/responsive observers (pause during drag to avoid jitter) */
let ro = null, globalListenersAttached = false;
function attachEvents(){
  leftCol.querySelectorAll('.item .handle').forEach(h=> addStartDragHandler(h,'left'));
  rightCol.querySelectorAll('.item .handle').forEach(h=> addStartDragHandler(h,'right'));

  if (!ro){
    ro = new ResizeObserver(()=>{
      if (dragActive) return; // avoid layout shifts while dragging
      setColumnUniformWidths();
      equaliseRowHeights();
      rafRealign();
    });
    ro.observe(board);
  }
  if (!globalListenersAttached){
    globalListenersAttached = true;
    window.addEventListener('scroll', ()=>{ if(!dragActive) rafRealign(); }, {passive:true});
    window.addEventListener('resize', ()=>{
      if (dragActive) return;
      setColumnUniformWidths(); equaliseRowHeights(); rafRealign();
    }, {passive:true});
  }
}

function updateCheckState(){ checkBtn.disabled = connections.size !== PAIRS.length; }

/* Buttons */
checkBtn.addEventListener('click', ()=>{
  showTimerIfHidden(); startTimerAndMusic();
  let ok=0;
  for(const [leftId, conn] of [...connections]){
    const correct = leftId === conn.rightId;
    if(correct){
      const okColor = getComputedStyle(document.documentElement).getPropertyValue('--ok').trim() || '#1E8E3E';
      conn.el.setAttribute('stroke', okColor);
      conn.el.setAttribute('stroke-width', 4);
      conn.el.setAttribute('stroke-opacity', '1');
      ok++;
    }else{
      conn.el.remove(); connections.delete(leftId);
    }
  }
  if (ok === PAIRS.length){ correctSound.currentTime=0; correctSound.play(); freezeTimerWithMessage(); bgm.pause(); }
  else { incorrectSound.currentTime=0; incorrectSound.play(); }
  updateCheckState();
});

resetBtn.addEventListener('click', ()=>{
  clickSound.currentTime=0; clickSound.play();
  if (timerHiddenForAnswers || timerFrozen){ showTimerResetToZero(); bgm.pause(); } else { showTimerIfHidden(); }
  wires.querySelectorAll('*').forEach(n=>n.remove());
  connections.clear(); clearPending(); updateCheckState(); rafRealign();
});

shuffleBtn.addEventListener('click', ()=>{
  showTimerIfHidden(); startTimerAndMusic();
  clickSound.currentTime=0; clickSound.play();
  leftOrder=shuffle(PAIRS); rightOrder=shuffle(PAIRS);
  wires.querySelectorAll('*').forEach(n=>n.remove());
  connections.clear(); clearPending(); render();
});

showBtn.addEventListener('click', ()=>{
  showTimerIfHidden(); startTimerAndMusic();
  clickSound.currentTime=0; clickSound.play();
  wires.querySelectorAll('*').forEach(n=>n.remove()); connections.clear(); clearPending();
  for(const pair of PAIRS){
    const lH = leftCol.querySelector(`.item[data-id="${pair.id}"] .handle`);
    const rH = rightCol.querySelector(`.item[data-id="${pair.id}"] .handle`);
    if(lH && rH){
      const el = makeConnectorElement('--ok', 4);
      placeConnector(el, handleCenter(lH), handleCenter(rH), '--ok', 4);
      wires.appendChild(el);
    }
  }
  checkBtn.disabled=true; bgm.pause(); hideTimerKeepSpace();
});

/* Mute button */
bgm.addEventListener('playing', ()=>{ if(!hasAudioPlayed){ hasAudioPlayed=true; muteBtn.style.display='inline-block'; } });
muteBtn.addEventListener('click', ()=>{
  const isMuted = !bgm.muted;
  bgm.muted = isMuted;
  muteBtn.setAttribute('aria-pressed', String(isMuted));
  muteBtn.setAttribute('aria-label', isMuted ? 'Unmute background music' : 'Mute background music');
});

/* Init */
(function init(){
  timerEl.textContent='00:00';
  leftOrder = shuffle(PAIRS);
  rightOrder = shuffle(PAIRS);
  render();

  if (document.fonts && document.fonts.ready) {
    document.fonts.ready.then(()=>{ setColumnUniformWidths(); equaliseRowHeights(); rafRealign(); });
  }
  window.addEventListener('load', ()=>{ setColumnUniformWidths(); equaliseRowHeights(); rafRealign(); });
})();
</script>
</body>
</html>
