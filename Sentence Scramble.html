<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5" />
<title>Sentence Scramble â€“ Present Perfect Simple 1 (Urban Living)</title>
<style>
  :root{
    --bg:#FDFBED;
    --ink:#111;
    --accent:#8A0000;
    --ok:#1E8E3E;
  }

  *{ box-sizing:border-box }
  html,body{ height:100% }

  body{
    margin:0;
    font-family:"MS Reference Sans Serif", Arial, sans-serif;
    background:var(--bg);
    color:var(--ink);
    display:flex;
    flex-direction:column;
    align-items:center;
    padding:20px 14px 48px;
  }

  h1{
    color:#111;
    margin:0 0 12px 0;
    font-size:clamp(20px,3.2vw,28px);
    letter-spacing:.2px;
  }

  .instructions{
    margin:0 0 10px 0;
    font-size:clamp(14px,2.6vw,16px);
    text-align:center;
    max-width:900px;
  }

  /* Landscape tip: centred IN THE FLOW (one line) */
  .landscape-tip{
    display:none; /* JS toggles to flex when needed */
    align-items:center;
    justify-content:center;
    gap:10px;
    width:min(1000px,96vw);
    margin:8px auto 10px;
    background:#fff;
    border:1px solid #dcd6be;
    color:#222;
    border-radius:12px;
    padding:10px 14px;
    font-size:clamp(13px,2.6vw,15px);
    line-height:1.35;
    box-shadow:0 3px 10px rgba(0,0,0,.08);
    text-align:center;
  }
  .landscape-tip .icon{ font-size:1.15em }

  /* Top bar: timer + mute inline; reserve height to avoid jiggle */
  .topbar{
    width:min(1000px,96vw);
    display:flex; align-items:center; justify-content:space-between;
    margin:8px auto 10px; gap:12px; flex-wrap:nowrap;
    min-height:40px;
  }
  .timer{
    background:#111; color:#fff; padding:6px 12px; border-radius:999px;
    font-weight:600; letter-spacing:.3px; box-shadow:0 2px 10px rgba(0,0,0,.12);
    font-variant-numeric:tabular-nums; white-space:nowrap;
  }
  .muteBtn{
    display:inline-flex; align-items:center; justify-content:center;
    background:transparent; border:none; padding:6px;
    width:40px; height:40px; border-radius:999px; cursor:pointer; line-height:0; flex:0 0 auto;
    visibility:hidden; opacity:0; pointer-events:none;
  }
  .muteBtn--ready{ visibility:visible; opacity:1; pointer-events:auto; }
  .muteBtn:focus-visible{ outline:2px solid #000; outline-offset:2px; }
  .muteBtn img{ width:24px; height:24px; display:block; }

  .activity-wrap{ position:relative; width:min(1000px,96vw); margin:0 auto; }

  .counter{
    text-align:center; font-weight:700;
    font-size:clamp(18px,3.8vw,24px);
    margin:4px 0 6px;
  }

  .stage{
    display:flex; flex-wrap:wrap; gap:10px 12px; justify-content:center; align-items:center;
    min-height:120px; margin:6px auto 10px; padding:0;
    contain:layout paint; isolation:isolate; transform:translateZ(0);
  }

  .word{
    background:#fff; border:1px solid #BDBDBD; border-radius:14px; padding:14px 16px;
    cursor:grab; user-select:none; -webkit-user-select:none; -webkit-touch-callout:none; -webkit-tap-highlight-color:transparent;
    font-weight:bold; line-height:1.15; box-shadow:0 2px 6px rgba(0,0,0,.06);
    font-size:clamp(18px,3.6vw,28px);
    touch-action:none; backface-visibility:hidden; transform:translateZ(0);
    transition:transform .12s ease, box-shadow .12s ease, background-color .15s ease, border-color .15s ease, color .15s ease;
  }
  .word:active{ cursor:grabbing; transform:scale(.985) translateZ(0) }
  .word.dragging{ opacity:.95; transition:none !important; will-change:transform; }
  .word.placeholder{ visibility:hidden; }

  .drag-ghost{
    position:fixed; left:0; top:0; z-index:9999;
    pointer-events:none; opacity:.97;
    box-shadow:0 6px 18px rgba(0,0,0,.18);
    transform:translate(-9999px,-9999px) translateZ(0);
    will-change:transform; backface-visibility:hidden;
  }

  .word.success{ background:#DFF5E3; border-color:var(--ok); color:#0b4c1c; }

  .controls{ display:flex; gap:10px; justify-content:flex-end; margin-top:8px; }
  .btn{
    background:var(--accent); color:#fff; border:none; padding:10px 16px; border-radius:10px;
    font-weight:600; letter-spacing:.2px; cursor:pointer; box-shadow:0 3px 10px rgba(138,0,0,.25);
    transition:background .2s, transform .15s;
  }
  .btn:hover{ transform:translateY(-1px) }
  .btn:active{ transform:translateY(0) scale(.98) }
  .btn.ghost{ background:#eee; color:#111; box-shadow:none; }
  .btn[disabled]{ opacity:.5; cursor:not-allowed; box-shadow:none; pointer-events:none; }

  @keyframes fadeIn{ from{opacity:0; transform:translateY(6px) scale(.985)} to{opacity:1; transform:translateY(0) scale(1)} }
  @keyframes fadeOut{ from{opacity:1; transform:translateY(0) scale(1)} to{opacity:0; transform:translateY(-6px) scale(.985)} }
  .fade-in{ animation:fadeIn .35s ease forwards }
  .fade-out{ animation:fadeOut .25s ease forwards }

  #congratsOverlay{
    position:absolute; inset:0; display:none; align-items:center; justify-content:center;
    z-index:99999; pointer-events:none;
  }
  #congratsOverlay[aria-hidden="false"]{ display:flex; }
  #congratsOverlay img{ width:clamp(160px,50%,400px); height:auto; animation:none; will-change:transform,opacity; }
  @keyframes congratsZoom{ 0%{transform:scale(.70);opacity:0} 8%{opacity:1} 100%{transform:scale(1.0);opacity:1} }

  @media (max-width:520px){
    .stage{ min-height:100px }
    .muteBtn{ width:36px; height:36px; padding:6px; } .muteBtn img{ width:22px; height:22px; }
    .timer{ padding:5px 10px; }
    .controls{ justify-content:center; flex-wrap:wrap; } /* centre buttons on mobile */
  }
</style>
</head>
<body>

<h1>Sentence Scramble</h1>
<p class="instructions">
  Unscramble the words to make a correct sentence in <b>Present Perfect</b>.
</p>

<div class="landscape-tip" id="landscapeTip" role="note" aria-live="polite">
  <span class="icon" aria-hidden="true">ðŸ“±â†»</span>
  <span>Tip: for more space, turn your phone to landscape.</span>
</div>

<div class="topbar">
  <div class="timer" id="timer">00:00</div>
  <button class="muteBtn" id="muteBtn" aria-pressed="false" aria-label="Mute background music" title="Mute" aria-hidden="true">
    <img id="muteIcon" alt="" src="https://schredder222.github.io/Assets/Unmute.svg" />
  </button>
</div>

<div class="activity-wrap" id="activityWrap">
  <div class="counter" id="counter">1 / 8</div>
  <div class="stage fade-in" id="stage"></div>

  <div class="controls">
    <button class="btn ghost" id="shuffleBtn" type="button">shuffle</button>
    <button class="btn" id="resetBtn" type="button">Restart quiz</button>
  </div>

  <div id="congratsOverlay" aria-hidden="true">
    <img src="https://schredder222.github.io/Assets/OutOfThisWorld!.png" alt="Out of this world!">
  </div>
</div>

<!-- Audio -->
<audio id="bgm" src="https://cdn.pixabay.com/download/audio/2024/02/10/audio_58dac346c5.mp3" loop preload="auto"></audio>
<audio id="sfxCorrect" src="https://cdn.pixabay.com/download/audio/2022/03/24/audio_dcde83efa6.mp3?filename=ui_correct_button2-103167.mp3" preload="auto"></audio>
<audio id="applause" src="https://schredder222.github.io/Assets/Applause.mp3" preload="auto"></audio>
<audio id="sfxDrop" src="https://cdn.pixabay.com/download/audio/2025/03/20/audio_99fc376452.mp3?filename=ui-pop-sound-316482.mp3" preload="auto"></audio>
<audio id="sfxShuffle" src="https://cdn.pixabay.com/download/audio/2025/07/30/audio_b3087a581e.mp3" preload="auto"></audio>
<!-- Restart sound effect (as requested) -->
<audio id="sfxReset" src="https://cdn.pixabay.com/download/audio/2024/04/21/audio_1b8d3bcd3d.mp3?filename=click-buttons-ui-menu-sounds-effects-button-7-203601.mp3" preload="auto"></audio>

<script>
/* --------------------------
   DATA (A2, Present Perfect; no ever/never)
--------------------------- */
const items = [
  { answer:["I","have","visited","London."] },
  { answer:["She","has","not","lived","in","a","big","city."] },
  { answer:["They","have","moved","to","Melbourne."] },
  { answer:["We","have","not","seen","a","concert","in","the","park."] },
  { answer:["Has","he","taken","the","underground?"] },
  { answer:["The","two","cities","have","had","a","rivalry","since","2000."] },
  { answer:["Have","you","visited","Sydney","or","Melbourne?"] },
  { answer:["My","friends","have","found","an","apartment."] }
];

const stage = document.getElementById('stage');
const counterEl = document.getElementById('counter');
const overlay = document.getElementById('congratsOverlay');

const bgm = document.getElementById('bgm');
const sfxCorrect = document.getElementById('sfxCorrect');
const applause = document.getElementById('applause');
const sfxDrop = document.getElementById('sfxDrop');
const sfxShuffle = document.getElementById('sfxShuffle');
const sfxReset = document.getElementById('sfxReset');

const timerEl = document.getElementById('timer');
const muteBtn = document.getElementById('muteBtn');
const muteIcon = document.getElementById('muteIcon');
const MUTE_ICON_URL   = 'https://schredder222.github.io/Assets/Mute.svg';
const UNMUTE_ICON_URL = 'https://schredder222.github.io/Assets/Unmute.svg';

const shuffleBtn = document.getElementById('shuffleBtn');
const resetBtn   = document.getElementById('resetBtn');

/* volumes */
bgm.volume = 0.40; sfxCorrect.volume = 1.0; applause.volume = 1.0;
sfxDrop.volume = 0.8; sfxShuffle.volume = 1.0; sfxReset.volume = 1.0;

/* state */
let idx = 0;                  // position within the RANDOM order
let order = [];               // random order of anagrams
let locked = false;
let timerInterval = null, elapsedMs = 0, startedAt = null;
let hasStartedActivity = false;
let celebrating = false, overlayTimeoutId = null, successTimeoutId = null;
const IS_COARSE = (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) || ('ontouchstart' in window);
let desktopBound = false, touchBound = false;

/* --------------------------
   LANDSCAPE TIP (portrait touch only)
--------------------------- */
const tipEl = document.getElementById('landscapeTip');
function updateLandscapeTip(){
  const isPortraitMQ = window.matchMedia && window.matchMedia('(orientation: portrait)').matches;
  const isPortraitFallback = window.innerHeight > window.innerWidth + 20;
  const isPortrait = isPortraitMQ || isPortraitFallback;
  const smallWidth = window.innerWidth <= 700;
  tipEl.style.display = (IS_COARSE && isPortrait && smallWidth) ? 'flex' : 'none';
}
window.addEventListener('resize', updateLandscapeTip, {passive:true});
window.addEventListener('orientationchange', updateLandscapeTip, {passive:true});

/* --------------------------
   HELPERS
--------------------------- */
function shuffled(a){ a=a.slice(); for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]} return a; }
function resetOrder(){ order = shuffled([...items.keys()]); idx = 0; }
function currentItem(){ return items[ order[idx] ]; }
function shuffledFromAnswer(ans){
  const target = ans.join(' ');
  for(let t=0;t<10;t++){ const c=shuffled(ans); if(c.join(' ') ) if(c.join(' ')!==target) return c; }
  return shuffled(ans);
}
function fmtTime(s){ const m=String(Math.floor(s/60)).padStart(2,'0'); const ss=String(s%60).padStart(2,'0'); return `${m}:${ss}`; }

/* --------------------------
   TIMER
--------------------------- */
function startTimer(){
  if(timerInterval) return;
  startedAt = performance.now() - elapsedMs;
  timerInterval = setInterval(()=>{
    elapsedMs = performance.now() - startedAt;
    timerEl.textContent = fmtTime(Math.floor(elapsedMs/1000));
  }, 250);
}
function stopTimer(){ clearInterval(timerInterval); timerInterval=null; }

/* --------------------------
   MUSIC + MUTE
--------------------------- */
function syncMuteIcon(){
  muteBtn.setAttribute('aria-pressed', String(bgm.muted));
  muteIcon.src = bgm.muted ? MUTE_ICON_URL : UNMUTE_ICON_URL;
  muteBtn.title = bgm.muted ? 'Unmute' : 'Mute';
  muteBtn.setAttribute('aria-label', bgm.muted ? 'Unmute background music' : 'Mute background music');
}
function revealMuteButton(){ muteBtn.classList.add('muteBtn--ready'); muteBtn.removeAttribute('aria-hidden'); syncMuteIcon(); }
muteBtn.addEventListener('click', ()=>{ bgm.muted=!bgm.muted; syncMuteIcon(); });
bgm.addEventListener('playing', revealMuteButton);

/* Try to play; if blocked on mobile, arm one-shot unlock listeners */
async function ensureAudio(){
  try{
    bgm.currentTime=0; await bgm.play(); revealMuteButton();
  }catch{
    const opts={once:true,passive:true};
    const unlock=async ()=>{
      try{ bgm.currentTime=0; await bgm.play(); revealMuteButton(); }catch{}
      window.removeEventListener('pointerup',unlock,opts);
      window.removeEventListener('touchend',unlock,opts);
      window.removeEventListener('click',unlock,opts);
      window.removeEventListener('keydown',unlock,opts);
    };
    window.addEventListener('pointerup',unlock,opts);
    window.addEventListener('touchend',unlock,opts);
    window.addEventListener('click',unlock,opts);
    window.addEventListener('keydown',unlock,opts);
  }
}
async function startActivityIfNeeded(){
  if(hasStartedActivity) return;
  hasStartedActivity = true;
  await ensureAudio();
  startTimer();
}

/* --------------------------
   RENDER & CHECK
--------------------------- */
function renderCurrent(){
  stage.innerHTML = "";
  stage.classList.remove('fade-out'); stage.classList.add('fade-in');
  counterEl.textContent = `${idx+1} / ${items.length}`;

  const tokens = shuffledFromAnswer(currentItem().answer);
  tokens.forEach(token=>{
    const w = document.createElement('div');
    w.className = 'word';
    w.textContent = token;
    w.draggable = !IS_COARSE;  // desktop native DnD only
    stage.appendChild(w);
  });
}
function wordsOf(){ return [...stage.querySelectorAll('.word')]; }
function textArray(){ return wordsOf().map(w=>w.textContent); }
function isCorrect(){ return textArray().join(' ') === currentItem().answer.join(' '); }

/* --------------------------
   CELEBRATION
--------------------------- */
function setControlsDuringCelebration(on){ shuffleBtn.disabled = on; shuffleBtn.setAttribute('aria-disabled', String(on)); }
function endCelebration(){
  celebrating=false; if(overlayTimeoutId){ clearTimeout(overlayTimeoutId); overlayTimeoutId=null; }
  overlay.setAttribute('aria-hidden','true');
  try{ applause.pause(); applause.currentTime=0; }catch{}
  setControlsDuringCelebration(false);
}
function showCongrats(){
  const img = overlay.querySelector('img'); img.style.animation='none'; void img.offsetWidth;
  img.style.animation='congratsZoom 8s ease-out forwards';
  celebrating=true; setControlsDuringCelebration(true);
  overlay.setAttribute('aria-hidden','false');
  try{ applause.currentTime=0; applause.play(); }catch{}
  overlayTimeoutId = setTimeout(()=>endCelebration(), 9000);
}
function markSuccessForTwoSecondsThenNext(){
  wordsOf().forEach(w=>w.classList.add('success'));
  try{ sfxCorrect.currentTime=0; sfxCorrect.play(); }catch{}
  locked = true;
  successTimeoutId = setTimeout(()=>{
    successTimeoutId=null;
    if(idx < items.length-1){
      idx++; locked=false; renderCurrent(); attachTouchDnDIfNeeded(); bindDesktopDnD();
    }else{
      try{ bgm.pause(); }catch{}
      stopTimer(); timerEl.textContent = `Completed in ${fmtTime(Math.floor(elapsedMs/1000))}`;
      showCongrats();
    }
  }, 2000);
}

/* --------------------------
   DESKTOP DnD
--------------------------- */
function bindDesktopDnD(){
  if(IS_COARSE || desktopBound) return; desktopBound = true;
  let dragWord=null;
  document.addEventListener('dragstart', async e=>{
    if(locked) return e.preventDefault();
    if(e.target.classList.contains('word')){ await startActivityIfNeeded(); dragWord=e.target; dragWord.classList.add('dragging'); }
  }, {passive:false});
  document.addEventListener('dragend', e=>{ if(e.target.classList.contains('word')){ e.target.classList.remove('dragging'); dragWord=null; }});
  stage.addEventListener('dragover', e=>{
    if(locked) return; e.preventDefault();
    const words = wordsOf().filter(n=>n!==dragWord);
    const after = words.find(el => e.clientX < el.getBoundingClientRect().left + el.offsetWidth/2);
    if(after) stage.insertBefore(dragWord, after); else stage.appendChild(dragWord);
  });
  document.addEventListener('drop', ()=>{ if(locked) return; try{ sfxDrop.currentTime=0; sfxDrop.play(); }catch{} if(isCorrect()) markSuccessForTwoSecondsThenNext(); });
}

/* --------------------------
   TOUCH / POINTER DnD (flicker-free)
--------------------------- */
function attachTouchDnDIfNeeded(){
  if(!IS_COARSE || touchBound) return; touchBound = true;

  let dragging=null, rafId=null, pendingMove=null;

  function scheduleMove(x,y){
    pendingMove = {x,y};
    if(rafId) return;
    rafId = requestAnimationFrame(()=>{
      const pt = pendingMove; rafId=null; if(!dragging || !pt) return;
      moveGhost(pt.x, pt.y);
      insertPlaceholderAt(pt.x, pt.y);
      if(pendingMove && (pendingMove.x!==pt.x || pendingMove.y!==pt.y)) scheduleMove(pendingMove.x, pendingMove.y);
    });
  }
  function moveGhost(x,y){
    if(!dragging) return;
    dragging.ghost.style.transform = `translate(${Math.round(x-dragging.offX)}px, ${Math.round(y-dragging.offY)}px) translateZ(0)`;
  }

  function computeRows(){
    const items = [...stage.children].filter(el=>el!==dragging?.placeholder);
    const rects = items.map(el=>({el, r: el.getBoundingClientRect()}));
    rects.sort((a,b)=>a.r.top - b.r.top);
    const rows=[]; const EPS=14;
    for(const it of rects){
      if(!rows.length || Math.abs(rows[rows.length-1][0].r.top - it.r.top) > EPS){ rows.push([it]); }
      else rows[rows.length-1].push(it);
    }
    return rows;
  }
  function insertPlaceholderAt(clientX, clientY){
    if(!dragging) return;
    const rows = computeRows();
    if(rows.length===0) return;

    const TOL=18;
    let row = rows[0];
    for(const r of rows){
      const top = Math.min(...r.map(x=>x.r.top));
      const bot = Math.max(...r.map(x=>x.r.bottom));
      if(clientY >= top - TOL && clientY <= bot + TOL){ row = r; break; }
      if(clientY > bot + TOL) row = r;
    }

    const HYST = 10;
    let beforeEl = null;
    for(const it of row){
      const mid = it.r.left + it.r.width/2;
      if(clientX < mid - HYST){ beforeEl = it.el; break; }
    }

    const currentIndex = [...stage.children].indexOf(dragging.placeholder);
    let targetIndex;
    if(beforeEl){ targetIndex = [...stage.children].indexOf(beforeEl); }
    else{ targetIndex = stage.children.length; }
    if(targetIndex !== currentIndex){
      if(targetIndex >= stage.children.length) stage.appendChild(dragging.placeholder);
      else stage.insertBefore(dragging.placeholder, stage.children[targetIndex]);
    }
  }

  function endTouchDrag(e){
    if(!dragging) return;
    const {tile, ghost, placeholder} = dragging;
    const i = [...stage.children].indexOf(placeholder);
    if(i >= stage.children.length) stage.appendChild(tile); else stage.insertBefore(tile, stage.children[i]);
    tile.style.visibility = ''; tile.classList.remove('dragging');
    ghost.remove(); placeholder.remove();
    document.body.style.touchAction = '';
    dragging = null;
    try{ sfxDrop.currentTime=0; sfxDrop.play(); }catch{}
    if(isCorrect()) markSuccessForTwoSecondsThenNext();
  }

  stage.addEventListener('pointerdown', async (e)=>{
    const t = e.target;
    if(!t.classList.contains('word') || locked) return;
    await startActivityIfNeeded();
    e.preventDefault();

    const rect = t.getBoundingClientRect();
    const ghost = t.cloneNode(true);
    ghost.classList.add('drag-ghost','dragging');
    ghost.style.width = rect.width + 'px';
    ghost.style.height = rect.height + 'px';
    document.body.appendChild(ghost);

    const placeholder = document.createElement('div');
    placeholder.className = 'word placeholder';
    placeholder.style.width = rect.width + 'px';
    placeholder.style.height = rect.height + 'px';
    stage.insertBefore(placeholder, t);

    t.style.visibility = 'hidden';
    t.classList.add('dragging');

    dragging = { tile:t, ghost, placeholder, offX:e.clientX-rect.left, offY:e.clientY-rect.top };
    scheduleMove(e.clientX, e.clientY);
    document.body.style.touchAction='none';

    const onMove = (ev)=>{ if(!dragging) return; ev.preventDefault(); scheduleMove(ev.clientX, ev.clientY); };
    const onUp   = (ev)=>{
      window.removeEventListener('pointermove', onMove, {passive:false});
      window.removeEventListener('pointerup', onUp, {passive:false});
      window.removeEventListener('pointercancel', onUp, {passive:false});
      endTouchDrag(ev);
    };
    window.addEventListener('pointermove', onMove, {passive:false});
    window.addEventListener('pointerup', onUp, {passive:false});
    window.addEventListener('pointercancel', onUp, {passive:false});
  }, {passive:false});
}

/* --------------------------
   BUTTONS
--------------------------- */
function shuffleCurrent(){
  if(locked || isCorrect()) return;
  try{ sfxShuffle.currentTime=0; sfxShuffle.play(); }catch{}
  const nodes = wordsOf();
  const shuffledNodes = nodes.slice().sort(()=>Math.random()-0.5);
  stage.innerHTML = '';
  shuffledNodes.forEach(n=>{ n.classList.remove('success','dragging'); n.draggable = !IS_COARSE; stage.appendChild(n); });
}

async function resetActivity(){
  if(celebrating) endCelebration();
  if(successTimeoutId){ clearTimeout(successTimeoutId); successTimeoutId=null; }
  locked=false;

  /* play the requested restart sound */
  try{ sfxReset.currentTime=0; sfxReset.play(); }catch{}

  // Back to the very start with a NEW random order
  resetOrder();

  // Reset timer (donâ€™t start until first drag)
  stopTimer(); elapsedMs=0; startedAt=null; timerEl.textContent='00:00';

  // Reset music (donâ€™t play until first drag)
  try{ bgm.pause(); bgm.currentTime=0; }catch{}
  muteBtn.classList.remove('muteBtn--ready'); muteBtn.setAttribute('aria-hidden','true');
  hasStartedActivity=false; setControlsDuringCelebration(false);

  renderCurrent();
}

shuffleBtn.addEventListener('click', shuffleCurrent);
resetBtn.addEventListener('click', resetActivity);

/* --------------------------
   INIT
--------------------------- */
resetOrder();
renderCurrent();
attachTouchDnDIfNeeded();
bindDesktopDnD();
updateLandscapeTip();
timerEl.textContent = '00:00';
</script>
</body>
</html>
